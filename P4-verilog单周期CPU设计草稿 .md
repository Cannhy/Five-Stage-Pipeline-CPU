# <center> Verilog单周期CPU设计文档  
## 一、CPU设计方案综述
***
### （一）总体设计概述  
* 使用Verilog语言开发一个简单的单周期CPU，总体概述如下：  
  1. 此CPU为支持32位运算的单周期CPU  
  2. 此CPU支持的指令集为  
    {add，sub，ori，lw，sw，beq，lui，jal，jr，nop}  
  3. nop指令的机器码为 0x00000000  
  4. add与sub指令不支持溢出  
### （二）模块规格  
1. PC
* （1）端口说明  
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | clk |      I    |    时钟信号  |
  | 2  | reset     | I |    同步复位信号  |
  | 3  | PC_in [31:0]     | I |    PC当前时刻的值  |
  | 4  | PC_out [31:0]     | O |    下一时刻PC的值  |  
* （2）功能定义  
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 同步复位 |      时钟上升沿且reset有效时，PC置为0x0000_3000    |
  | 2 | 更新PC |      时钟上升沿到来时，更新PC    |
  | 4 | 输出PC |      输出当前PC的值   |
2. IM
* （1）端口说明 
    | 序号 | 信号名 | 方向   | 描述 |
    | :-----: | :---------: | :--------: | :----: |
    | 1  | add [31:0]     | I |    根据输入的PC值取指令  |
    | 2  | Instr [31:0]     | O |    输出当前指令  |  
* （2）功能定义  
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 取出指令 |      输出当前的指令    |
  | 2 | 输入PC |      根据PC的值取出相应指令    |
3. grf
* (1)端口说明
  | 序号 | 信号名 | 方向 | 描述       |
  | :----: | :------: | :----: | :------------: |
  |  1    | clk    | I    | 时钟信号 |
  |  2    | reset  | I    | 异步复位信号 |
  |  3   | WE | I    | 写使能信号 |
  |  4    | A1 [4:0]  | I    | 5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1 |
  |  5    | A2 [4:0]  | I    | 5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2 |
    |  6    | A3 [4:0]  | I    | 5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD3 |
  |  7    | WD [31:0]  | I    | 32位写入数据 |
    |  8    | RD1 [31:0]  | O    | 输出A1指定的寄存器的32位数据 |
    |  9    | RD2 [31:0]  | O    | 输出A2指定的寄存器的32位数据 |
* （2）功能定义  
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 异步复位 |      reset有效时，所有寄存器清零    |
  | 2 | 读数据 |     将A1和A2地址对应的寄存器的值分别通过RD1和RD2读出   |
  | 3 | 写数据 |     当WE为1且时钟上升沿来临时，将WD写入到A3对应的寄存器内部    |
4. ALU
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | A [31:0] |      I    |    参与运算的第一个数  |
  | 2  | B [31:0]    | I |    参与运算的第二个数  |
  | 3  | ALUOp [2:0]     | I |    决定ALU做何种运算    |  
  ||  |  |  000 ：无符号加  |
    ||  |  |  001 ：无符号减  |
    ||  |  |  010 ：或  |
  | 4  | zero     | O |    A与B是否相等 |
  | 5  | result[31:0]     | O |    ALU运算结果  |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 加运算 |      result = A + B    |
  | 2 | 减运算 |      result = A - B    |
  | 3 | 或运算 |     result = A &#124; B    |
  | 4 | 与运算 |      result = A & B   |
5. DM
* (1)端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | clk |      I    |    时钟信号  |
  | 2  | reset    | I |    异步复位信号数  |
  | 3  | WE     | I |    写使能信号    |  
  | 4  | WD [31:0]     | I  |    32位写入数据 |
  | 5  | RD[31:0]     | O |    32位读出数据  |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 异步复位 |      reset有效时，所有寄存器清零    |
  | 2 | 读数据 |     RD读出A对应的DM地址中的值   |
  | 3 | 写数据 |     当WE有效时，时钟上升沿来临时，WD中数据写入A对应的DM地址中    |
6. EXT
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | imm16[15:0] |      I    |    需要扩展的16位信号 |
  | 2  |sign    | I |    扩展选择信号 
  ||  |  |  0 ：无符号扩展  |
    ||  |  |  1 ：有符号扩展  |
  | 3  | imm32[31:0]     | O |    扩展后的输出信号   |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 无符号扩展 |      当sign为0时，将imm16无符号扩展输出    |
  | 2 | 有符号扩展 |     当sign为1时，将imm16有符号扩展输出   |

7. NPC
* (1) 端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | imm26[25:0] |      I    |    需要跳转的26位信号 |
  | 2  |ra [31:0]   | I |    31号寄存器内的地址 
  | 3  | zero     | I |    是否根据beq跳转   |  
  | 4  | PC [31:0]    | I |    当前PC的值   |  
  | 5  | NPCOp [2:0]     | I |    NPC控制信号   |  
  | 6  | PC + 4 [31:0]     | O |    PC不跳转情况下的下一个值   |  
  | 7  | NPC [31:0]    | O |    PC下一时刻的值   |  
 * (2) 功能说明  
    | 序号 | 功能 |  描述 |  
    | :-----: | :---------: |  :----: |  
    | 1 | 计算下一时刻PC值 |      根据控制信号计算PC'的值    |
    | 2 | 计算顺序执行时PC'值 |     输出PC + 4 的值   |
8. Mux
 * (1) 端口说明
    | 序号 | 信号名 | 方向   | 描述 |
    | :-----: | :---------: | :--------: | :----: |
    | 1 | M1sel [2:0] |      I    |    多路选择器1的控制信号 |
    | 2  |M2sel [3:0]   | I |    多路选择器2的控制信号 
    | 3  | M3sel [2:0]     | I |    多路选择器3的控制信号   |  
    | 4  | M1_in0 [4:0]   | I |    多路选择器1的输入0   |  
    | 5  | M1_in1 [4:0]    | I |    多路选择器的输入1   |  
    | 6  | M2_in0 [31:0]    | I |    多路选择器2的输入0   |  
    | 7  | M2_in1 [31:0]    | I |    多路选择器2的输入1   |  
    | 8  | M2_in2 [31:0]    | I |    多路选择器2的输入2   |  
    | 9  | M3_in0 [31:0]    | I |    多路选择器3的输入0   |  
    | 10  | M3_in1 [31:0]    | I |    多路选择器3的输入1   |  
    | 11  | M3_in2 [31:0]    | I |    多路选择器3的输入2   |  
    | 12  | M1_out [5:0]    | O |    多路选择器1的输出   |  
    | 13  | M2_out [31:0]    | O |    多路选择器2的输出   |  
    | 14  | M3_out [31:0]    | O |    多路选择器3的输出   |  
 * (2) 功能说明  
    | 序号 | 功能 |  描述 |  
    | :-----: | :---------: |  :----: |  
    | 1 | 数据选择输出 |      根据控制信号输出所需要的值    |
9.  Controller
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | Opcode [5:0] |      I    |    instr [31:26] 6位控制信号 |
  | 2  |func [5:0]    | I |    instr [0:5] 6位控制信号 
  | 3  | ALUOp [2:0]     | O |    ALU控制信号   |  
  | 4  | RfWr     | O |    GRF写使能信号   |  
    | 5  | DMWr     | O |    DM写使能信号   |  
   | 6 | ExtOp     | O |    Ext控制信号   |  
    | 7  | M1sel [1:0]     | O |    M1控制信号   |  
     | 8  | M1sel [1:0]     | O |    M2控制信号   | 
     | 9  | M1sel [2:0]     | O |    M3控制信号   | 
    | 10  | NPCOp [2:0]     | O |    NPC控制信号   | 
* （2）真值表
  | 指令 | NPCOp |  RFWr | EXTOp |  ALUOp | DMWr | M1sel | M2sel | M3sel | 
  | :-----: | :---------: |  :----: |    :----: |  :----: |  :----: |  :----: |  :----: |  :----: |
  | add | 000(PC+4) |      1    | 0 |  000(add) | 0 | 00 | 00 | 000 | 
  | sub | 000(PC+4) |      1    | 0 |  001(sub) | 0 | 00 | 00 | 000 | 
  | ori | 000(PC+4) |      1    | 0 |  010(or) | 0 | 01 | 00 | 001 | 
  | lui | 000(PC+4) |      1    | 0 |  000(add) | 0 | 01 | 00 | 010 | 
  | lw | 000(PC+4) |      1    | 1 |  000(add) | 0 | 01 | 01 | 001 | 
  | sw | 000(PC+4) |      0    | 1 |  000(add) | 1 | xx | xx | 001 |
  | beq | 001(br) |      0    | x |  001(sub) | 0 | xx | xx | 000 |
  | jal | 010(jal) |      1    | x |  xxx | 0 | 10 | 10 | xxx |
  | jr | 011(jr) |      0   | x |  xxx | 0 | xx | xx | xxx |
  | nop | 000(PC+4) |      0    | x |  xxx | 0 | xx | xx | xxx |
## 二、测试方案
***
1. 测试代码  

* 测试ori指令  
  > .text
ori $0, $0, 0  
ori $1, $1, 1  
ori $2, $2, -2  
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, -5  
ori $6, $6, -6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, -9   
ori $10, $10, -10  
ori $11, $11, 11  
ori $12, $12, 12  
ori $13, $13, 13  
ori $14, $14, 14  
ori $15, $15, -15  
ori $16, $16, 16  
ori $17, $17, 17  
ori $18, $18, 18  
ori $19, $19, -19  
ori $20, $20, 20  
ori $21, $21, 21  
ori $22, $22, -22  
ori $23, $23, 23  
ori $24, $24, 24  
ori $25, $25, -25  
ori $26, $26, 26  
ori $27, $27, -27  
ori $28, $28, 28  
ori $29, $29, 29  
ori $30, $30, -30  
ori $31, $31, 0 

* 测试beq，add，sub指令
   > .text  
   .text
ori $t1, $t1, 2  
ori $t2, $t2, 3  
ori $t3, $t3, 4  
start:  
beq $t1, $t2, jump  
ori $t4, $t5, 10  
ori $t6, $t7, 11  
ori $t8, $t8, 12  
jump:  
addu $t4, $t1, $t2  
addu $t5, $t2, $t3  
beq $t1, $t3, start  
ori $s1, $s1, 6  
ori $s2, $s2, 7  
subu $s1 $s1,  $t1  
subu  $s2, $s2, $t2  
* 测试sw指令  
  >.test
ori $1, $1, 1  
ori $2, $2, 2 
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, 5  
ori $6, $6, 6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, 9  
ori $10, $10, -4
ori $11, $11, 12
sw $1, 4($11)  
sw $2, 0($11)  
sw $3, -4($11)  
sw $4, 4($0)  
sw $5, 0($0)  
sw $6, 4($10)  
sw $7, 0($10)  
* 测试lw指令
  >.test  
  ori $1, $1, 1  
ori $2, $2, 2  
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, 5  
ori $6, $6, 6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, 9  
ori $10, $10, -4
ori $11, $11, 12
sw $1, 4($11)  
sw $2, 0($11)  
sw $3, -4($11)  
sw $4, 4($0)  
sw $5, 0($0)  
sw $6, 4($10)  
sw $7, 0($10)  
lw $8, 4($11)  
lw $9, 0($11)  
lw $10, -4($11)  
lw $11, 4($0)  
lw $12, 0($0)  
lw $13, 4($10)  
lw $14, 0($10) 
* 测试lui指令
  >.text  
ori $1, $1, 5  
ori $2, $2, 23  
lui $3, 0x1023  
lui $4, 0x5678  
ori $5, $5, 50  
ori $6, $6, 60  
addu $7, $3, $4  
addu $8  $5, $6  

## 三、思考题  
 1. 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？
 * 答 ：  addr 来自 ALU 的输出端口，代表要读取或者要写入的 DM 存储器的地址，在 4KB 的 DM 设计中应当取 [11:0]，因为mips按字节寻址，而DM中是以字寻址，因此相差四倍，所以在DM中寻址需要除以4，所以取 [11:2]即可。
 2. 思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。
 * 答 ：
     > assign ALUOp = (opcode == beq || (R_type == 1 && funct == sub))? 3'b001 : 
	                (opcode == ori)? 3'b010 : 3'b000;  
      
    > case(opcode)  
          add: ALUOp = 3'b000;    
          sub: ALUOp = 3'b001;    
          ori: ALUOp = 3'b010;    
          lui: ALUOp = 3'b000;  
          beq: ALUOp = 3'b001;    
          jal: ALUOp = 3'b000;
          jr:  ALUOp = 3'b000;  
          nop: ALUOp = 3'b000;  
    endcase  
  
     其中，assign语句不需要自己再定义寄存器；case-endcase和assign可以通过宏定义的方式，使代码更加美观，增强可读性。
 3. 在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。
* 答 ： 对于同步复位而言，clk信号优先级高于reset信号，必须在时钟上升沿到来的时候reset信号才可以有效；对于异步复位而言，reset信号优先级高于clk信号，reset信号有效时，不管clk是否有效到会到达复位状态。
 4. C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。
 * 答 ：addi与addiu的区别在于，当出现溢出时，addiu忽略溢出，将溢出的最高位舍弃；addi会报告SignalException(IntegerOverflow)。故忽略溢出时，二者等价。