# <center> Verilog流水线CPU设计文档  
## 一、CPU设计方案综述
***
### （一）总体设计概述  
* 使用Verilog语言开发一个简单的流水线CPU，总体概述如下：  
  1. 此CPU为支持32位运算的单周期CPU  
  2. 此CPU支持的指令集为  
    {add，sub，and, or, slt, sltu, slt, addi, andi, ori, lb,lh,sb, sh, mult, multu, div, divu, mfhi, mflo, mthi, mtlo, bne, ori，lw，sw，beq，lui，jal，jr，nop}  
  3. nop指令的机器码为 0x00000000  
  4. add,addi与sub,subi指令不支持溢出  
### （二）模块规格  
1. IFU
* （1）端口说明  
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | clk |      I    |    时钟信号  |
  | 2  | reset     | I |    同步复位信号  |
  | 3  | NPC [31:0]     | I |    PC下一时刻的值  |
  | 4  | F_en     | I |    PC寄存器使能端  |
  | 5  | F_PC [31:0]     | O |    PC取值地址  |  
  | 6  | F_Instr [31:0]     | O |    F级取出的指令  |  
* （2）功能定义  
  1. 复位至0x0000_3000;
  2. 在时钟上升沿更新PC的值；
  3. 根据当前PC值取出指令；
  4. 冻结寄存器，当F_en为0时，PC无法得到更新。
2. GRF
* （1）端口说明 
    | 序号 | 信号名 | 方向   | 描述 |
    | :-----: | :---------: | :--------: | :----: |
    | 1  | clk     | I |    时钟信号  |
    | 2  | reset     | I |    同步复位信号  |  
    | 3  | WE     | I |    寄存器写使能 |  
    | 4  | A1[4:0]     | I |    5位地址输入信号，读出到RD1  |  
    | 5  | A2[4:0]     | I |    5位地址输入信号，读出到RD2 |  
    | 6  | A3[4:0]     | I |    5位地址输入信号，将WD存储到对应寄存器 | 
    | 7  | WD[31:0]     | I |    要存储的值 | 
    | 8  | W_PC[31:0]     | I |    用于输出当前指令的地址 | 
    | 9  | RD1[31:0]     | I |    A1读出的值 | 
    | 10  | RD2[31:0]     | I |    A2读出的值 | 
* （2）功能定义  
  1. 复位清零寄存器所存储内容；
  2. 读取寄存器的数据；
  3. 在写使能有效时，时钟上升沿将WD存储到A3对应的寄存器中；
  4. 内部转发。

3. DM
* (1)端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | clk |      I    |    时钟信号  |
  | 2  | reset    | I |    异步复位信号数  |
  | 3  | WE     | I |    写使能信号    |  
  | 4  | WD [31:0]     | I  |    32位写入数据 |
  | 5  | addr [31:0]     | I  |    32位地址 |
  | 6  | pc [31:0]     | I  |    当前指令的地址 |
  | 7  | RD[31:0]     | O |    32位读出数据  |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 异步复位 |      reset有效时，所有寄存器清零    |
  | 2 | 读数据 |     RD读出A对应的DM地址中的值   |
  | 3 | 写数据 |     当WE有效时，时钟上升沿来临时，WD中数据写入A对应的DM地址中    |
4. ALU
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | A [31:0] |      I    |    参与运算的第一个数  |
  | 2  | B [31:0]    | I |    参与运算的第二个数  |
  | 3  | ALUOp [2:0]     | I |    决定ALU做何种运算    |  
  ||  |  |  000 ：无符号加  |
    ||  |  |  001 ：无符号减  |
    ||  |  |  010 ：或  |
  | 4  | zero     | O |    A与B是否相等 |
  | 5  | result[31:0]     | O |    ALU运算结果  |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 加运算 |      result = A + B    |
  | 2 | 减运算 |      result = A - B    |
  | 3 | 或运算 |     result = A &#124; B    |
  | 4 | 与运算 |      result = A & B   |
5. NPC
* (1) 端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | imm26[25:0] |      I    |    需要跳转的26位信号 |
  | 2  |ra [31:0]   | I |    31号寄存器内的地址 
  | 3  | zero     | I |    是否根据beq跳转   |  
  | 4  | PC [31:0]    | I |    当前PC的值   |  
  | 5  | NPCOp [2:0]     | I |    NPC控制信号   |  
  | 6  | PC + 4 [31:0]     | O |    PC不跳转情况下的下一个值   |  
  | 7  | NPC [31:0]    | O |    PC下一时刻的值   |  
 * (2) 功能说明  
    | 序号 | 功能 |  描述 |  
    | :-----: | :---------: |  :----: |  
    | 1 | 计算下一时刻PC值 |      根据控制信号计算PC'的值    |
    | 2 | 计算顺序执行时PC'值 |     输出PC + 4 的值   |
6. EXT
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | imm16[15:0] |      I    |    需要扩展的16位信号 |
  | 2  |ExtOp    | I |    扩展选择信号 
  | 3  | imm32[31:0]     | O |    扩展后的输出信号   |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 无符号扩展 |      当ExtOp为2'b00时，将imm16无符号扩展输出    |
  | 2 | 有符号扩展 |     当ExtOp为2'b01时，将imm16有符号扩展输出   |
  | 3 | 加载至最高位 |     当sign为2'b10时，将imm16加载至高位输出   |

7.  Controller
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | Instr [31:0] |      I    |    当前指令 |
  | 3  | ALUOp [2:0]     | O |    ALU控制信号   |  
  | 4  | RfWr     | O |    GRF写使能信号   |  
    | 5  | DMWr     | O |    DM写使能信号   |  
   | 6 | ExtOp[1:0]     | O |    Ext控制信号   |  
    | 7  | Src_AlU_B [2:0]     | O |    ALU的B端口输入选择信号   |  
     | 8  | tuse_rs [1:0]     | O |    需要rs数据的周期   | 
     | 9  | tuse_rt [1:0]     | O |    需要rt数据的周期   | 
    | 10  | E_tnew [1:0]     | O |   E级产生新数据所需周期数   | 
    | 11  | M_tnew [1:0]     | O |    M级产生新数据所需周期数   | 
    | 12  | A3 [4:0]     | O |    要写入的寄存器地址   | 
    | 13  | RF_WD_type [1:0]     | O |    要写入寄存器的的数据类型   | 
    | 14  | NPCOp [2:0]     | O |    NPC控制信号   | 
* （2）真值表
  | 控制信号 | add/sub |  jr | lw |  sw | beq | ori | lui | jal |
  | :-----: | :---------: |  :----: |    :----: |  :----: |  :----: |  :----: |  :----: |  :----: |
  | RfWr | 1 |    0    | 1 |  0 | 0 | 1 | 1 | 1 | 
  | DMWr | 0 |    0    | 0 |  1 | 0 | 0 | 0 | 0 | 
  | ExtOp | 2'b00 |      2'b00    | 2'b01 |  2'b01 | 2'b00 | 2'b00 | 2'b10 | 3'b000 | 
  | ALUOp | 3'b000/3'b001 |      3'b000    | 3'b000 |  3'b000 | 3'b000 | 3'b010 | 3'b000 | 3'b000 | 
  | Src_ALU_B | 3'b000 |      3'b000    | 3'b001 |  3'b001 | 3'b000 | 3'b001 | 3'b001 | 3'b000 | 
  | NPCOp | 3'b000 |      3'b011    | 3'b000 | 3'b000 | 3'b001 |3'b000 | 3'b000 | 3'b010 |
  | A3 | Instr[15:11] |      x    | Instr[20:16] |  x | x | Instr[20:16] | Instr[20:16] | 5'd31 |
  | RF_WD_type | ALU_result |      x    | DM_out |  x | x | ALU_result | ALU_result | PC+4 |
  | tuse_rs | 2'b01 |      2'b00   | 2'b01 |  2'b01 | 2'b00 | 2'b01 | 2'b11 | 2'b11 |
  | tuse_rt | 2'b01 |      2'b11    | 2'b11 |  2'b11 | 2'b00 | 2'b11 | 2'b11 | 2'b11 |
  | E_tnew | 2'b01 |      2'b00    | 2'b10 |  2'b00 | 2'b00 | 2'b01 | 2'b00 | 2'b00 |
  | M_tnew | 2'b00 |      2'b00    | 2'b01 |  2'b00 | 2'b00 | 2'b00 | 2'b00 | 2'b00 |
## 二、测试方案
***
1. 测试代码  

* 测试ori指令  
  > .text
ori $0, $0, 0  
ori $1, $1, 1  
ori $2, $2, -2  
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, -5  
ori $6, $6, -6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, -9   
ori $10, $10, -10  
ori $11, $11, 11  
ori $12, $12, 12  
ori $13, $13, 13  
ori $14, $14, 14  
ori $15, $15, -15  
ori $16, $16, 16  
ori $17, $17, 17  
ori $18, $18, 18  
ori $19, $19, -19  
ori $20, $20, 20  
ori $21, $21, 21  
ori $22, $22, -22  
ori $23, $23, 23  
ori $24, $24, 24  
ori $25, $25, -25  
ori $26, $26, 26  
ori $27, $27, -27  
ori $28, $28, 28  
ori $29, $29, 29  
ori $30, $30, -30  
ori $31, $31, 0 

* 测试beq，add，sub指令
   > .text  
ori $t1, $t1, 2  
ori $t2, $t2, 3  
ori $t3, $t3, 4  
start:  
beq $t1, $t2, jump  
ori $t4, $t5, 10  
ori $t6, $t7, 11  
ori $t8, $t8, 12  
jump:  
addu $t4, $t1, $t2  
addu $t5, $t2, $t3  
beq $t1, $t3, start  
ori $s1, $s1, 6  
ori $s2, $s2, 7  
subu $s1 $s1,  $t1  
subu  $s2, $s2, $t2  
* 测试sw指令  
  >.text
ori $1, $1, 1  
ori $2, $2, 2 
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, 5  
ori $6, $6, 6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, 9  
ori $10, $10, -4
ori $11, $11, 12
sw $1, 4($11)  
sw $2, 0($11)  
sw $3, -4($11)  
sw $4, 4($0)  
sw $5, 0($0)  
sw $6, 4($10)  
sw $7, 0($10)  
* 测试lw指令
  >.text  
  ori $1, $1, 1  
ori $2, $2, 2  
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, 5  
ori $6, $6, 6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, 9  
ori $10, $10, -4
ori $11, $11, 12
sw $1, 4($11)  
sw $2, 0($11)  
sw $3, -4($11)  
sw $4, 4($0)  
sw $5, 0($0)  
sw $6, 4($10)  
sw $7, 0($10)  
lw $8, 4($11)  
lw $9, 0($11)  
lw $10, -4($11)  
lw $11, 4($0)  
lw $12, 0($0)  
lw $13, 4($10)  
lw $14, 0($10) 
* 测试lui指令
  >.text  
ori $1, $1, 5  
ori $2, $2, 23  
lui $3, 0x1023  
lui $4, 0x5678  
ori $5, $5, 50  
ori $6, $6, 60  
addu $7, $3, $4  
addu $8  $5, $6  
* 测试转发
  >.text  
ori $22, $0, 64  
ori $1, $0, 116  
ori $4, $0, 140  
ori $28, $0, 228   
ori $29, $0, 228  
addu $18 $28 $22  
addu $29 $1 $18  
addu $4 $29 $18  
addu $5 $4 $18  
lw $20 100($0)  
sw $24 100($0)  
* 测试暂停
  >.text  
lw $t1, 120($0)   
beq $t1,$t2, label4  
nop  
ori $s3, $s3,3  
ori $s4, $s4,4  
label4:  
ori $5, $5, 5  
ori $6, $6, 6  
ori $t1, $t1, 400  
ori $t2, $t2, 600  
ori $t3, $t3, 100  
ori $t4, $t4, 50  
sw $t3, 100($0)  
lw $t4, 100($0)  
subu $t1, $t1,$t4  
addu $t2, $t2, $t4  

## 三、思考题  
 1. 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？
 * 答 ： ​ ALU模块为组合逻辑，乘除法部件是时序逻辑，运用单独的乘除法部件可以避免逻辑时序的混乱。乘法和除法指令在程序中的运行分别为5个周期、10周期，如果将乘除法部件整合进ALU，会影响CPU的执行效率。将乘除法部件独立，可以使后续的涉及乘除部件的指令正常流水下去，在乘除法运算的周期，可以继续执行其他指令，提高CPU整体效率。
 2. 真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。
 * 答 ：乘法 首先CPU会初始化三个通用寄存器用来存放被乘数，乘数，部分积的二进制数，部分积寄存器初始化为0！ 然后在判断乘数寄存器的低位是低电平还是高电平（0/1）！ 如果为0则将乘数寄存器右移一位，同时将部分积寄存器也右移一位，在位移时遵循计算机位移规则，乘数寄存器低位溢出的一位丢弃，部分积寄存器低位溢出的一位填充到乘数寄存器的高位，同时部分积寄存器高位补0！ 如果为1则将部分积寄存器加上被乘数寄存器，在进移位操作。 当所有乘数位处理完成后部分积寄存器做高位乘数寄存器做低位就是最终乘法结果！
除法
   首先CPU会初始化三个寄存器,用来存放被除数，除数，部分商！余数(被除数与除数比较的结果)放到被除数的有效高位上！ CPU做除法时和做除法时是相反的，乘法是右移，除法是左移，乘法做的是加法，除法做的是减法。 首先CPU会把被除数bit位与除数bit位对齐，然后在让对齐的被除数与除数比较(双符号位判断)。 这里说一下什么是双符号位判断： 比如01-10=11(前面的1是符号位) 1-2=-1 计算机通过符号位和后一位的bit位来判断大于和小于，那么01-10=11 就说明01小于10，如果得数为01就代表大于，如果得数为00代表等于。 如果得数大于或等于则将比较的结果放到被除数的有效高位上然后在商寄存器上商：1 并向后多看一位 (上商就是将商的最低位左移1位腾出商寄存器最低位上新的商) 如果得数小于则上商：0 并向后多看一位 然后循环做以上操作当所有的被除数都处理完后，商做结果被除数里面的值就是余数！
 3. 请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？
* 答 ： 在SU中通过以下代码实现阻塞：  即若D级为乘除法指令且busy有效即阻塞
  >assign E_stall_mdu = (D_md | D_mt | D_mf) && (busy | start); 
 4. 请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）
 * 答 ：清晰性：采用字节使能信号对于每一条指令可以通过观察byteen信号即可知道要读或者写某个字的哪一个字节，清晰直观；  
 * 统一性：所有存取指令都可以有byteen判断要读或者写内存字的哪个位置，符合了高内聚、低耦合的设计理念，更具统一性。
 5. 请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？
 * 答 ：需求者可能是D级的RD1和RD2、E级的A输入和B输入、M级的Wdata；供给者可能是E/M级寄存器保存的ALU输出、M/W级寄存器保存的ALU输出和DM的输出、PC+8；
 * 转发通路：M级寄存器到D级RD1或者RD2，W级寄存器到D级RD1和RD2，W级寄存器到E级A和B。
 6. 为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？
 * 答 ：我采取了指令分类的方法。将指令分为cal_r、cal_i、lui_type、md、mt、mf、j_imm、j_r、store、load、setlt，不同类型的指令控制信号与tuse、tnew大致相同，因此添加新指令时，加入符合的类，转发部分不用更改，暂停部分加一个因MDU导致的暂停即可。
 7. 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？ 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。
 * 答 ：本实验遇到的冲突主要是引入MDU后产生的冲突。解决办法：在D级检测是否要使用MDU或者使用MDU产生的数据，是的话就要考虑暂停阻塞。
      测试样例：
   >  mult $1, $2
  div $1, $2  
  mflo $3  
  add $1, $2, $3  
  div $1, $2  
  mflo 2
  ori $1, $0, 1
  ori $2, $0, 6      
  ori $3, $0, 4  
  ori $4, $0, 4  
  sw $4, 0($0)  
  sw $3, 4($0)  
  sw $1, 8($0)  
  sw $1, 12($0)  
  sw $3, 100($0)  
  sw $2, 104($0)  
  sw $2, 108($0)  
  sw $4, 112($0)  
  sw $3, 116($0)  
  lb $1, 0($2)  
  mthi 1  
  lw $8, 100($0)  
  lw $9, 112($0)  
  mult $8, $9  
  mfhi 11  
  mflo $12  

    手动构造样例：将可能的转发和阻塞数据考虑即可，比如mult要读寄存器，但是mult的上一条指令要写该寄存器，mult要用mdu，下一条指令也要用mdu，或者下一条指令要读hi、lo寄存器，所有可能的情况考虑到便覆盖了所有测试情况。