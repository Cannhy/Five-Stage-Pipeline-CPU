# <center> Logisim单周期CPU设计文档  
## 一、CPU设计方案综述
***
### （一）总体设计概述  
* 使用Logisim开发一个简单的单周期CPU，总体概述如下：  
  1. 此CPU为支持32位运算的单周期CPU  
  2. 此CPU支持的指令集为  
    {add，sub，ori，lw，sw，beq，lui，jal，jr，nop}  
  3. nop指令的机器码为 0x00000000  
  4. add与sub指令不支持溢出  
### （二）模块规格  
1. IFU
* （1）端口说明  
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | clk |      I    |    时钟信号  |
  | 2  | reset     | I |    异步复位信号  |
  | 3  | PC' [31:0]     | I |    PC下一时刻的值  |
  | 4  | Instr [31:0]     | O |    本时刻PC取出的指令  |
  | 5  | PC[31:0]     | O |    当前时刻PC的值  |  
* （2）功能定义  
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 异步复位 |      reset有效时，PC置为0x00000000    |
  | 2 | 更新PC |      时钟上升沿到来时，更新PC    |
  | 3 | 输出指令 |     根据PC的值取出指令    |
  | 4 | 输出PC |      输出当前PC从而计算PC'   |
2. grf
* (1)端口说明
  | 序号 | 信号名 | 方向 | 描述       |
  | :----: | :------: | :----: | :------------: |
  |  1    | clk    | I    | 时钟信号 |
  |  2    | reset  | I    | 异步复位信号 |
  |  3   | WE | I    | 写使能信号 |
  |  4    | A1 [4:0]  | I    | 5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1 |
  |  5    | A2 [4:0]  | I    | 5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2 |
    |  6    | A3 [4:0]  | I    | 5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD3 |
  |  7    | WD [31:0]  | I    | 32位写入数据 |
    |  8    | RD1 [31:0]  | O    | 输出A1指定的寄存器的32位数据 |
    |  9    | RD2 [31:0]  | O    | 输出A2指定的寄存器的32位数据 |
* （2）功能定义  
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 异步复位 |      reset有效时，所有寄存器清零    |
  | 2 | 读数据 |     将A1和A2地址对应的寄存器的值分别通过RD1和RD2读出   |
  | 3 | 写数据 |     当WE为1且时钟上升沿来临时，将WD写入到A3对应的寄存器内部    |
3. ALU
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | A [31:0] |      I    |    参与运算的第一个数  |
  | 2  | B [31:0]    | I |    参与运算的第二个数  |
  | 3  | ALUOp [2:0]     | I |    决定ALU做何种运算    |  
  ||  |  |  000 ：无符号加  |
    ||  |  |  001 ：无符号减  |
    ||  |  |  010 ：或  |
  | 4  | zero     | O |    A与B是否相等 |
  | 5  | result[31:0]     | O |    ALU运算结果  |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 加运算 |      result = A + B    |
  | 2 | 减运算 |      result = A - B    |
  | 3 | 或运算 |     result = A &#124; B    |
  | 4 | 与运算 |      result = A & B   |
4. DM
* (1)端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | clk |      I    |    时钟信号  |
  | 2  | reset    | I |    异步复位信号数  |
  | 3  | WE     | I |    写使能信号    |  
  | 4  | WD [31:0]     | I  |    32位写入数据 |
  | 5  | RD[31:0]     | O |    32位读出数据  |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 异步复位 |      reset有效时，所有寄存器清零    |
  | 2 | 读数据 |     RD读出A对应的DM地址中的值   |
  | 3 | 写数据 |     当WE有效时，时钟上升沿来临时，WD中数据写入A对应的DM地址中    |
5. EXT
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | imm16[15:0] |      I    |    需要扩展的16位信号 |
  | 2  |sign    | I |    扩展选择信号 
  ||  |  |  0 ：无符号扩展  |
    ||  |  |  1 ：有符号扩展  |
  | 3  | imm32[31:0]     | O |    扩展后的输出信号   |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 无符号扩展 |      当sign为0时，将imm16无符号扩展输出    |
  | 2 | 有符号扩展 |     当sign为1时，将imm16有符号扩展输出   |

6. NPC
* (1) 端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | imm26[25:0] |      I    |    需要跳转的26位信号 |
  | 2  |ra [31:0]   | I |    31号寄存器内的地址 
  | 3  | zero     | I |    是否根据beq跳转   |  
  | 4  | PC [31:0]    | I |    当前PC的值   |  
  | 5  | NPCOp [2:0]     | I |    NPC控制信号   |  
  | 6  | PC + 4 [31:0]     | O |    PC不跳转情况下的下一个值   |  
  | 7  | NPC [31:0]    | O |    PC下一时刻的值   |  
 * (2) 功能说明  
    | 序号 | 功能 |  描述 |  
    | :-----: | :---------: |  :----: |  
    | 1 | 计算下一时刻PC值 |      根据控制信号计算PC'的值    |
    | 2 | 计算顺序执行时PC'值 |     输出PC + 4 的值   |
7. Controller
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | Opcode [5:0] |      I    |    instr [31:26] 6位控制信号 |
  | 2  |func [5:0]    | I |    instr [0:5] 6位控制信号 
  | 3  | ALUOp [2:0]     | O |    ALU控制信号   |  
  | 4  | RfWr     | O |    GRF写使能信号   |  
    | 5  | DMWr     | O |    DM写使能信号   |  
   | 6 | ExtOp     | O |    Ext控制信号   |  
    | 7  | M1sel [1:0]     | O |    M1控制信号   |  
     | 8  | M1sel [1:0]     | O |    M2控制信号   | 
     | 9  | M1sel [2:0]     | O |    M3控制信号   | 
    | 10  | NPCOp [2:0]     | O |    NPC控制信号   | 
* （2）真值表
  | 指令 | NPCOp |  RFWr | EXTOp |  ALUOp | DMWr | M1sel | M2sel | M3sel | 
  | :-----: | :---------: |  :----: |    :----: |  :----: |  :----: |  :----: |  :----: |  :----: |
  | add | 000(PC+4) |      1    | 0 |  000(add) | 0 | 00 | 00 | 000 | 
  | sub | 000(PC+4) |      1    | 0 |  001(sub) | 0 | 00 | 00 | 000 | 
  | ori | 000(PC+4) |      1    | 0 |  010(or) | 0 | 01 | 00 | 001 | 
  | lui | 000(PC+4) |      1    | 0 |  000(add) | 0 | 01 | 00 | 010 | 
  | lw | 000(PC+4) |      1    | 1 |  000(add) | 0 | 01 | 01 | 001 | 
  | sw | 000(PC+4) |      0    | 1 |  000(add) | 1 | xx | xx | 001 |
  | beq | 001(br) |      0    | x |  001(sub) | 0 | xx | xx | 000 |
  | jal | 010(jal) |      1    | x |  xxx | 0 | 10 | 10 | xxx |
  | jr | 011(jr) |      0   | x |  xxx | 0 | xx | xx | xxx |
  | nop | 000(PC+4) |      0    | x |  xxx | 0 | xx | xx | xxx |
## 二、测试方案
***
1. 测试代码  

* 测试ori指令  
  > .text
ori $0, $0, 0  
ori $1, $1, 1  
ori $2, $2, -2  
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, -5  
ori $6, $6, -6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, -9   
ori $10, $10, -10  
ori $11, $11, 11  
ori $12, $12, 12  
ori $13, $13, 13  
ori $14, $14, 14  
ori $15, $15, -15  
ori $16, $16, 16  
ori $17, $17, 17  
ori $18, $18, 18  
ori $19, $19, -19  
ori $20, $20, 20  
ori $21, $21, 21  
ori $22, $22, -22  
ori $23, $23, 23  
ori $24, $24, 24  
ori $25, $25, -25  
ori $26, $26, 26  
ori $27, $27, -27  
ori $28, $28, 28  
ori $29, $29, 29  
ori $30, $30, -30  
ori $31, $31, 0 

* 测试beq，add，sub指令
   > .text  
   .text
ori $t1, $t1, 2  
ori $t2, $t2, 3  
ori $t3, $t3, 4  
start:  
beq $t1, $t2, jump  
ori $t4, $t5, 10  
ori $t6, $t7, 11  
ori $t8, $t8, 12  
jump:  
addu $t4, $t1, $t2  
addu $t5, $t2, $t3  
beq $t1, $t3, start  
ori $s1, $s1, 6  
ori $s2, $s2, 7  
subu $s1 $s1,  $t1  
subu  $s2, $s2, $t2  
* 测试sw指令  
  >.test
ori $1, $1, 1  
ori $2, $2, 2 
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, 5  
ori $6, $6, 6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, 9  
ori $10, $10, -4
ori $11, $11, 12
sw $1, 4($11)  
sw $2, 0($11)  
sw $3, -4($11)  
sw $4, 4($0)  
sw $5, 0($0)  
sw $6, 4($10)  
sw $7, 0($10)  
* 测试lw指令
  >.test  
  ori $1, $1, 1  
ori $2, $2, 2  
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, 5  
ori $6, $6, 6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, 9  
ori $10, $10, -4
ori $11, $11, 12
sw $1, 4($11)  
sw $2, 0($11)  
sw $3, -4($11)  
sw $4, 4($0)  
sw $5, 0($0)  
sw $6, 4($10)  
sw $7, 0($10)  
lw $8, 4($11)  
lw $9, 0($11)  
lw $10, -4($11)  
lw $11, 4($0)  
lw $12, 0($0)  
lw $13, 4($10)  
lw $14, 0($10) 
* 测试lui指令
  >.text  
ori $1, $1, 5  
ori $2, $2, 23  
lui $3, 0x1023  
lui $4, 0x5678  
ori $5, $5, 50  
ori $6, $6, 60  
addu $7, $3, $4  
addu $8  $5, $6  

## 三、思考题  
 1. 上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法，请大家画出单周期 CPU 对应有限状态机的状态转移图，并谈谈它和我们之前见过的状态转移图有什么不同。
 * 答 ：  
   ![markdown picture](C:\Users\86182\Desktop\CPUfsm.jpg)  
  该状态转移图的输出会影响有限状态机的下一条指令，比如取出的指令经过译码后（NPCOp和zero等）输入到NPC（状态转移）中，进而影响下一条PC的值，而不是单单依靠输入reset的值。
 1. 现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。
 * 答 ：合理。IM用来存储指令，在仿真开始之前导入，测试开始之后只需要从中读取指令，而不进行写入行为，对速度要求不高所以IM使用ROM是合理的；DM用来存储和写入数据，所以DM使用RAM也是合理的；而GRF经常对数据进行读写而且对速度要求高，所以GRF使用Register也合理。
 3. 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。
 * 答 ：我在设计CPU时还设计了NPC模块。NPC模块主要用来输出PC下一时刻的值，即PC'；另外还有一个专门的输出端口用来输出PC + 4 的值；设计NPC模块的目的主要是把Beq，jal，j和jr要跳转的目的地址集成到一起，根据NPCOp选择需要输出的地址；NPC + 4 端口方便直接将下一条指令的地址存储到31号寄存器中。通过设计NPC，尽量实现“高内聚，低耦合”。
 4. 事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？
 * 答 ：因为nop只需要计算一下PC + 4 的值并存储到PC中，不会影响后面的数据通路。不把nop加入真值表中，NPCOp默认是000会输出PC + 4，从而更新PC的值，因此不需要加入控制信号真值表。
 5. 上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。
 * 答 ：如果地址在0x30000000到0x3fffffff之间，且CPU地址从0开始的话，直接将地址减去0x30000000即可；如果DM起始地址未知的话，可以在DM设置两个RAM，比较地址和0x30000000，得到片选信号，从而根据信号选择所需的RAM。
 6. 阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。
 * 答 ：对于ori和lui测试，我认为还应该测试一下0（附近的数）和16位无符号数的边界数，可能会更充分；对于add指令，也应该测试一下32位数的边界数；对于lw和sw指令，也应该测试offset和基地址分别为正值，0和负值的情况；对于Beq指令，可以在跳转或者不跳转的情况下，将跳转地址放在当前地址之前或者之后或者就是当前指令。