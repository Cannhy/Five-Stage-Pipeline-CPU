# <center> Verilog流水线CPU设计文档  
## 一、CPU设计方案综述
***
### （一）总体设计概述  
* 使用Verilog语言开发一个简单的流水线CPU，总体概述如下：  
  1. 此CPU为支持32位运算的单周期CPU  
  2. 此CPU支持的指令集为  
    {add，sub，ori，lw，sw，beq，lui，jal，jr，nop}  
  3. nop指令的机器码为 0x00000000  
  4. add与sub指令不支持溢出  
### （二）模块规格  
1. IFU
* （1）端口说明  
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | clk |      I    |    时钟信号  |
  | 2  | reset     | I |    同步复位信号  |
  | 3  | NPC [31:0]     | I |    PC下一时刻的值  |
  | 4  | F_en     | I |    PC寄存器使能端  |
  | 5  | F_PC [31:0]     | O |    PC取值地址  |  
  | 6  | F_Instr [31:0]     | O |    F级取出的指令  |  
* （2）功能定义  
  1. 复位至0x0000_3000;
  2. 在时钟上升沿更新PC的值；
  3. 根据当前PC值取出指令；
  4. 冻结寄存器，当F_en为0时，PC无法得到更新。
2. GRF
* （1）端口说明 
    | 序号 | 信号名 | 方向   | 描述 |
    | :-----: | :---------: | :--------: | :----: |
    | 1  | clk     | I |    时钟信号  |
    | 2  | reset     | I |    同步复位信号  |  
    | 3  | WE     | I |    寄存器写使能 |  
    | 4  | A1[4:0]     | I |    5位地址输入信号，读出到RD1  |  
    | 5  | A2[4:0]     | I |    5位地址输入信号，读出到RD2 |  
    | 6  | A3[4:0]     | I |    5位地址输入信号，将WD存储到对应寄存器 | 
    | 7  | WD[31:0]     | I |    要存储的值 | 
    | 8  | W_PC[31:0]     | I |    用于输出当前指令的地址 | 
    | 9  | RD1[31:0]     | I |    A1读出的值 | 
    | 10  | RD2[31:0]     | I |    A2读出的值 | 
* （2）功能定义  
  1. 复位清零寄存器所存储内容；
  2. 读取寄存器的数据；
  3. 在写使能有效时，时钟上升沿将WD存储到A3对应的寄存器中；
  4. 内部转发。

3. DM
* (1)端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | clk |      I    |    时钟信号  |
  | 2  | reset    | I |    异步复位信号数  |
  | 3  | WE     | I |    写使能信号    |  
  | 4  | WD [31:0]     | I  |    32位写入数据 |
  | 5  | addr [31:0]     | I  |    32位地址 |
  | 6  | pc [31:0]     | I  |    当前指令的地址 |
  | 7  | RD[31:0]     | O |    32位读出数据  |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 异步复位 |      reset有效时，所有寄存器清零    |
  | 2 | 读数据 |     RD读出A对应的DM地址中的值   |
  | 3 | 写数据 |     当WE有效时，时钟上升沿来临时，WD中数据写入A对应的DM地址中    |
4. ALU
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | A [31:0] |      I    |    参与运算的第一个数  |
  | 2  | B [31:0]    | I |    参与运算的第二个数  |
  | 3  | ALUOp [2:0]     | I |    决定ALU做何种运算    |  
  ||  |  |  000 ：无符号加  |
    ||  |  |  001 ：无符号减  |
    ||  |  |  010 ：或  |
  | 4  | zero     | O |    A与B是否相等 |
  | 5  | result[31:0]     | O |    ALU运算结果  |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 加运算 |      result = A + B    |
  | 2 | 减运算 |      result = A - B    |
  | 3 | 或运算 |     result = A &#124; B    |
  | 4 | 与运算 |      result = A & B   |
5. NPC
* (1) 端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | imm26[25:0] |      I    |    需要跳转的26位信号 |
  | 2  |ra [31:0]   | I |    31号寄存器内的地址 
  | 3  | zero     | I |    是否根据beq跳转   |  
  | 4  | PC [31:0]    | I |    当前PC的值   |  
  | 5  | NPCOp [2:0]     | I |    NPC控制信号   |  
  | 6  | PC + 4 [31:0]     | O |    PC不跳转情况下的下一个值   |  
  | 7  | NPC [31:0]    | O |    PC下一时刻的值   |  
 * (2) 功能说明  
    | 序号 | 功能 |  描述 |  
    | :-----: | :---------: |  :----: |  
    | 1 | 计算下一时刻PC值 |      根据控制信号计算PC'的值    |
    | 2 | 计算顺序执行时PC'值 |     输出PC + 4 的值   |
6. EXT
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | imm16[15:0] |      I    |    需要扩展的16位信号 |
  | 2  |ExtOp    | I |    扩展选择信号 
  | 3  | imm32[31:0]     | O |    扩展后的输出信号   |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 无符号扩展 |      当ExtOp为2'b00时，将imm16无符号扩展输出    |
  | 2 | 有符号扩展 |     当ExtOp为2'b01时，将imm16有符号扩展输出   |
  | 3 | 加载至最高位 |     当sign为2'b10时，将imm16加载至高位输出   |

1.  Controller
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | Instr [31:0] |      I    |    当前指令 |
  | 3  | ALUOp [2:0]     | O |    ALU控制信号   |  
  | 4  | RfWr     | O |    GRF写使能信号   |  
    | 5  | DMWr     | O |    DM写使能信号   |  
   | 6 | ExtOp[1:0]     | O |    Ext控制信号   |  
    | 7  | Src_AlU_B [2:0]     | O |    ALU的B端口输入选择信号   |  
     | 8  | tuse_rs [1:0]     | O |    需要rs数据的周期   | 
     | 9  | tuse_rt [1:0]     | O |    需要rt数据的周期   | 
    | 10  | E_tnew [1:0]     | O |   E级产生新数据所需周期数   | 
    | 11  | M_tnew [1:0]     | O |    M级产生新数据所需周期数   | 
    | 12  | A3 [4:0]     | O |    要写入的寄存器地址   | 
    | 13  | RF_WD_type [1:0]     | O |    要写入寄存器的的数据类型   | 
    | 14  | NPCOp [2:0]     | O |    NPC控制信号   | 
* （2）真值表
  | 控制信号 | add/sub |  jr | lw |  sw | beq | ori | lui | jal |
  | :-----: | :---------: |  :----: |    :----: |  :----: |  :----: |  :----: |  :----: |  :----: |
  | RfWr | 1 |    0    | 1 |  0 | 0 | 1 | 1 | 1 | 
  | DMWr | 0 |    0    | 0 |  1 | 0 | 0 | 0 | 0 | 
  | ExtOp | 2'b00 |      2'b00    | 2'b01 |  2'b01 | 2'b00 | 2'b00 | 2'b10 | 3'b000 | 
  | ALUOp | 3'b000/3'b001 |      3'b000    | 3'b000 |  3'b000 | 3'b000 | 3'b010 | 3'b000 | 3'b000 | 
  | Src_ALU_B | 3'b000 |      3'b000    | 3'b001 |  3'b001 | 3'b000 | 3'b001 | 3'b001 | 3'b000 | 
  | NPCOp | 3'b000 |      3'b011    | 3'b000 | 3'b000 | 3'b001 |3'b000 | 3'b000 | 3'b010 |
  | A3 | Instr[15:11] |      x    | Instr[20:16] |  x | x | Instr[20:16] | Instr[20:16] | 5'd31 |
  | RF_WD_type | ALU_result |      x    | DM_out |  x | x | ALU_result | ALU_result | PC+4 |
  | tuse_rs | 2'b01 |      2'b00   | 2'b01 |  2'b01 | 2'b00 | 2'b01 | 2'b11 | 2'b11 |
  | tuse_rt | 2'b01 |      2'b11    | 2'b11 |  2'b11 | 2'b00 | 2'b11 | 2'b11 | 2'b11 |
  | E_tnew | 2'b01 |      2'b00    | 2'b10 |  2'b00 | 2'b00 | 2'b01 | 2'b00 | 2'b00 |
  | M_tnew | 2'b00 |      2'b00    | 2'b01 |  2'b00 | 2'b00 | 2'b00 | 2'b00 | 2'b00 |
## 二、测试方案
***
1. 测试代码  

* 测试ori指令  
  > .text
ori $0, $0, 0  
ori $1, $1, 1  
ori $2, $2, -2  
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, -5  
ori $6, $6, -6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, -9   
ori $10, $10, -10  
ori $11, $11, 11  
ori $12, $12, 12  
ori $13, $13, 13  
ori $14, $14, 14  
ori $15, $15, -15  
ori $16, $16, 16  
ori $17, $17, 17  
ori $18, $18, 18  
ori $19, $19, -19  
ori $20, $20, 20  
ori $21, $21, 21  
ori $22, $22, -22  
ori $23, $23, 23  
ori $24, $24, 24  
ori $25, $25, -25  
ori $26, $26, 26  
ori $27, $27, -27  
ori $28, $28, 28  
ori $29, $29, 29  
ori $30, $30, -30  
ori $31, $31, 0 

* 测试beq，add，sub指令
   > .text  
ori $t1, $t1, 2  
ori $t2, $t2, 3  
ori $t3, $t3, 4  
start:  
beq $t1, $t2, jump  
ori $t4, $t5, 10  
ori $t6, $t7, 11  
ori $t8, $t8, 12  
jump:  
addu $t4, $t1, $t2  
addu $t5, $t2, $t3  
beq $t1, $t3, start  
ori $s1, $s1, 6  
ori $s2, $s2, 7  
subu $s1 $s1,  $t1  
subu  $s2, $s2, $t2  
* 测试sw指令  
  >.text
ori $1, $1, 1  
ori $2, $2, 2 
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, 5  
ori $6, $6, 6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, 9  
ori $10, $10, -4
ori $11, $11, 12
sw $1, 4($11)  
sw $2, 0($11)  
sw $3, -4($11)  
sw $4, 4($0)  
sw $5, 0($0)  
sw $6, 4($10)  
sw $7, 0($10)  
* 测试lw指令
  >.text  
  ori $1, $1, 1  
ori $2, $2, 2  
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, 5  
ori $6, $6, 6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, 9  
ori $10, $10, -4
ori $11, $11, 12
sw $1, 4($11)  
sw $2, 0($11)  
sw $3, -4($11)  
sw $4, 4($0)  
sw $5, 0($0)  
sw $6, 4($10)  
sw $7, 0($10)  
lw $8, 4($11)  
lw $9, 0($11)  
lw $10, -4($11)  
lw $11, 4($0)  
lw $12, 0($0)  
lw $13, 4($10)  
lw $14, 0($10) 
* 测试lui指令
  >.text  
ori $1, $1, 5  
ori $2, $2, 23  
lui $3, 0x1023  
lui $4, 0x5678  
ori $5, $5, 50  
ori $6, $6, 60  
addu $7, $3, $4  
addu $8  $5, $6  
* 测试转发
  >.text  
ori $22, $0, 64  
ori $1, $0, 116  
ori $4, $0, 140  
ori $28, $0, 228   
ori $29, $0, 228  
addu $18 $28 $22  
addu $29 $1 $18  
addu $4 $29 $18  
addu $5 $4 $18  
lw $20 100($0)  
sw $24 100($0)  
* 测试暂停
  >.text  
lw $t1, 120($0)   
beq $t1,$t2, label4  
nop  
ori $s3, $s3,3  
ori $s4, $s4,4  
label4:  
ori $5, $5, 5  
ori $6, $6, 6  
ori $t1, $t1, 400  
ori $t2, $t2, 600  
ori $t3, $t3, 100  
ori $t4, $t4, 50  
sw $t3, 100($0)  
lw $t4, 100($0)  
subu $t1, $t1,$t4  
addu $t2, $t2, $t4  

## 三、思考题  
 1. 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。
 * 答 ： 提前分支判断可能会带来数据冒险，因为beq需要rs寄存器和rt寄存器的数据，如果beq的前一天指令需要将结果写入rs或rt的话，这样只能通过阻塞来解决冒险，比如以下指令序列：
   > add $1, $2, $3  
    beq $1, $2, label  
   beq在D级需要跳转的时候，$1中的数据还未更新，只能阻塞暂停。
 2. 因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？
 * 答 ：因为延迟槽的存在，jal等跳转指令在跳转后还会执行它的后一条指令，因此跳转回来后它的后一条指令已经被执行过了就不需要再执行一遍了，直接执行jal后的第二条指令就可以了，所以需要写回PC + 8 ；
 3. 我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？
* 答 ： 如果从功能部件转发，那么某一级的总延迟会增加，时钟周期也会因此增加，效率便会降低，不合理。
 4. 我们为什么要使用 GPR 内部转发？该如何实现？
 * 答 ：GRF采用内部转发可以将W级寄存器存贮的值直接实时反馈到GRF的输出端，本质上就是W级到D级的转发。
 5. 我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？
 * 答 ：需求者可能是D级的RD1和RD2、E级的A输入和B输入、M级的Wdata；供给者可能是E/M级寄存器保存的ALU输出、M/W级寄存器保存的ALU输出和DM的输出、PC+8；
 * 转发通路：M级寄存器到D级RD1或者RD2，W级寄存器到D级RD1和RD2，W级寄存器到E级A和B。
 6. 在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。
 * 答 ：对于新的指令，首先将新指令所需的控制信号行为进行更改，然后加入新指令的tuse_rs和tuse_rt，E_tnew,M_tnew，总的来说就是将我所设计的控制单元里的所有控制信号考虑一遍即可。
 7. 简要描述你的译码器架构，并思考该架构的优势以及不足。
 * 答 ：我的译码器是分布式译码，在每一个阶段进行一次译码，将该阶段所需要的控制信号引出。
 * 优势：减少了寄存器端口的数量，相对简洁，容易进行增量开发；
 * 不足：模块复用次数过多，可能会带来不必要的麻烦。