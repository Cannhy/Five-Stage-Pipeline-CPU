# <center> Verilog流水线CPU设计文档  
## 一、CPU设计方案综述
***
### （一）总体设计概述  
* 使用Verilog语言开发一个简单的流水线CPU，总体概述如下：  
  1. 此CPU为支持32位运算的单周期CPU  
  2. 此CPU支持的指令集为  
    {add，sub，and, or, slt, sltu, slt, addi, andi, ori, lb,lh,sb, sh, mult, multu, div, divu, mfhi, mflo, mthi, mtlo, bne, ori，lw，sw，beq，lui，jal，jr，nop}  
  3. nop指令的机器码为 0x00000000  
  4. add,addi与sub,subi指令不支持溢出  
### （二）模块规格  
1. IFU
* （1）端口说明  
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | clk |      I    |    时钟信号  |
  | 2  | reset     | I |    同步复位信号  |
  | 3  | NPC [31:0]     | I |    PC下一时刻的值  |
  | 4  | F_en     | I |    PC寄存器使能端  |
  | 5  | F_PC [31:0]     | O |    PC取值地址  |  
  | 6  | F_Instr [31:0]     | O |    F级取出的指令  |  
* （2）功能定义  
  1. 复位至0x0000_3000;
  2. 在时钟上升沿更新PC的值；
  3. 根据当前PC值取出指令；
  4. 冻结寄存器，当F_en为0时，PC无法得到更新。
2. GRF
* （1）端口说明 
    | 序号 | 信号名 | 方向   | 描述 |
    | :-----: | :---------: | :--------: | :----: |
    | 1  | clk     | I |    时钟信号  |
    | 2  | reset     | I |    同步复位信号  |  
    | 3  | WE     | I |    寄存器写使能 |  
    | 4  | A1[4:0]     | I |    5位地址输入信号，读出到RD1  |  
    | 5  | A2[4:0]     | I |    5位地址输入信号，读出到RD2 |  
    | 6  | A3[4:0]     | I |    5位地址输入信号，将WD存储到对应寄存器 | 
    | 7  | WD[31:0]     | I |    要存储的值 | 
    | 8  | W_PC[31:0]     | I |    用于输出当前指令的地址 | 
    | 9  | RD1[31:0]     | I |    A1读出的值 | 
    | 10  | RD2[31:0]     | I |    A2读出的值 | 
* （2）功能定义  
  1. 复位清零寄存器所存储内容；
  2. 读取寄存器的数据；
  3. 在写使能有效时，时钟上升沿将WD存储到A3对应的寄存器中；
  4. 内部转发。

3. DM
* (1)端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | clk |      I    |    时钟信号  |
  | 2  | reset    | I |    异步复位信号数  |
  | 3  | WE     | I |    写使能信号    |  
  | 4  | WD [31:0]     | I  |    32位写入数据 |
  | 5  | addr [31:0]     | I  |    32位地址 |
  | 6  | pc [31:0]     | I  |    当前指令的地址 |
  | 7  | RD[31:0]     | O |    32位读出数据  |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 异步复位 |      reset有效时，所有寄存器清零    |
  | 2 | 读数据 |     RD读出A对应的DM地址中的值   |
  | 3 | 写数据 |     当WE有效时，时钟上升沿来临时，WD中数据写入A对应的DM地址中    |
4. ALU
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | A [31:0] |      I    |    参与运算的第一个数  |
  | 2  | B [31:0]    | I |    参与运算的第二个数  |
  | 3  | ALUOp [2:0]     | I |    决定ALU做何种运算    |  
  ||  |  |  000 ：无符号加  |
    ||  |  |  001 ：无符号减  |
    ||  |  |  010 ：或  |
  | 4  | zero     | O |    A与B是否相等 |
  | 5  | result[31:0]     | O |    ALU运算结果  |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 加运算 |      result = A + B    |
  | 2 | 减运算 |      result = A - B    |
  | 3 | 或运算 |     result = A &#124; B    |
  | 4 | 与运算 |      result = A & B   |
5. NPC
* (1) 端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | imm26[25:0] |      I    |    需要跳转的26位信号 |
  | 2  |ra [31:0]   | I |    31号寄存器内的地址 
  | 3  | zero     | I |    是否根据beq跳转   |  
  | 4  | PC [31:0]    | I |    当前PC的值   |  
  | 5  | NPCOp [2:0]     | I |    NPC控制信号   |  
  | 6  | PC + 4 [31:0]     | O |    PC不跳转情况下的下一个值   |  
  | 7  | NPC [31:0]    | O |    PC下一时刻的值   |  
 * (2) 功能说明  
    | 序号 | 功能 |  描述 |  
    | :-----: | :---------: |  :----: |  
    | 1 | 计算下一时刻PC值 |      根据控制信号计算PC'的值    |
    | 2 | 计算顺序执行时PC'值 |     输出PC + 4 的值   |
6. EXT
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | imm16[15:0] |      I    |    需要扩展的16位信号 |
  | 2  |ExtOp    | I |    扩展选择信号 
  | 3  | imm32[31:0]     | O |    扩展后的输出信号   |  
* （2）功能定义
  | 序号 | 功能 |  描述 |  
  | :-----: | :---------: |  :----: |  
  | 1 | 无符号扩展 |      当ExtOp为2'b00时，将imm16无符号扩展输出    |
  | 2 | 有符号扩展 |     当ExtOp为2'b01时，将imm16有符号扩展输出   |
  | 3 | 加载至最高位 |     当sign为2'b10时，将imm16加载至高位输出   |

7.  Controller
* （1）端口说明
  | 序号 | 信号名 | 方向   | 描述 |
  | :-----: | :---------: | :--------: | :----: |
  | 1 | Instr [31:0] |      I    |    当前指令 |
  | 3  | ALUOp [2:0]     | O |    ALU控制信号   |  
  | 4  | RfWr     | O |    GRF写使能信号   |  
    | 5  | DMWr     | O |    DM写使能信号   |  
   | 6 | ExtOp[1:0]     | O |    Ext控制信号   |  
    | 7  | Src_AlU_B [2:0]     | O |    ALU的B端口输入选择信号   |  
     | 8  | tuse_rs [1:0]     | O |    需要rs数据的周期   | 
     | 9  | tuse_rt [1:0]     | O |    需要rt数据的周期   | 
    | 10  | E_tnew [1:0]     | O |   E级产生新数据所需周期数   | 
    | 11  | M_tnew [1:0]     | O |    M级产生新数据所需周期数   | 
    | 12  | A3 [4:0]     | O |    要写入的寄存器地址   | 
    | 13  | RF_WD_type [1:0]     | O |    要写入寄存器的的数据类型   | 
    | 14  | NPCOp [2:0]     | O |    NPC控制信号   | 
* （2）真值表
  | 控制信号 | add/sub |  jr | lw |  sw | beq | ori | lui | jal |
  | :-----: | :---------: |  :----: |    :----: |  :----: |  :----: |  :----: |  :----: |  :----: |
  | RfWr | 1 |    0    | 1 |  0 | 0 | 1 | 1 | 1 | 
  | DMWr | 0 |    0    | 0 |  1 | 0 | 0 | 0 | 0 | 
  | ExtOp | 2'b00 |      2'b00    | 2'b01 |  2'b01 | 2'b00 | 2'b00 | 2'b10 | 3'b000 | 
  | ALUOp | 3'b000/3'b001 |      3'b000    | 3'b000 |  3'b000 | 3'b000 | 3'b010 | 3'b000 | 3'b000 | 
  | Src_ALU_B | 3'b000 |      3'b000    | 3'b001 |  3'b001 | 3'b000 | 3'b001 | 3'b001 | 3'b000 | 
  | NPCOp | 3'b000 |      3'b011    | 3'b000 | 3'b000 | 3'b001 |3'b000 | 3'b000 | 3'b010 |
  | A3 | Instr[15:11] |      x    | Instr[20:16] |  x | x | Instr[20:16] | Instr[20:16] | 5'd31 |
  | RF_WD_type | ALU_result |      x    | DM_out |  x | x | ALU_result | ALU_result | PC+4 |
  | tuse_rs | 2'b01 |      2'b00   | 2'b01 |  2'b01 | 2'b00 | 2'b01 | 2'b11 | 2'b11 |
  | tuse_rt | 2'b01 |      2'b11    | 2'b11 |  2'b11 | 2'b00 | 2'b11 | 2'b11 | 2'b11 |
  | E_tnew | 2'b01 |      2'b00    | 2'b10 |  2'b00 | 2'b00 | 2'b01 | 2'b00 | 2'b00 |
  | M_tnew | 2'b00 |      2'b00    | 2'b01 |  2'b00 | 2'b00 | 2'b00 | 2'b00 | 2'b00 |
## 二、测试方案
***
1. 测试代码  

* 测试ori指令  
  > .text
ori $0, $0, 0  
ori $1, $1, 1  
ori $2, $2, -2  
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, -5  
ori $6, $6, -6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, -9   
ori $10, $10, -10  
ori $11, $11, 11  
ori $12, $12, 12  
ori $13, $13, 13  
ori $14, $14, 14  
ori $15, $15, -15  
ori $16, $16, 16  
ori $17, $17, 17  
ori $18, $18, 18  
ori $19, $19, -19  
ori $20, $20, 20  
ori $21, $21, 21  
ori $22, $22, -22  
ori $23, $23, 23  
ori $24, $24, 24  
ori $25, $25, -25  
ori $26, $26, 26  
ori $27, $27, -27  
ori $28, $28, 28  
ori $29, $29, 29  
ori $30, $30, -30  
ori $31, $31, 0 

* 测试beq，add，sub指令
   > .text  
ori $t1, $t1, 2  
ori $t2, $t2, 3  
ori $t3, $t3, 4  
start:  
beq $t1, $t2, jump  
ori $t4, $t5, 10  
ori $t6, $t7, 11  
ori $t8, $t8, 12  
jump:  
addu $t4, $t1, $t2  
addu $t5, $t2, $t3  
beq $t1, $t3, start  
ori $s1, $s1, 6  
ori $s2, $s2, 7  
subu $s1 $s1,  $t1  
subu  $s2, $s2, $t2  
* 测试sw指令  
  >.text
ori $1, $1, 1  
ori $2, $2, 2 
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, 5  
ori $6, $6, 6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, 9  
ori $10, $10, -4
ori $11, $11, 12
sw $1, 4($11)  
sw $2, 0($11)  
sw $3, -4($11)  
sw $4, 4($0)  
sw $5, 0($0)  
sw $6, 4($10)  
sw $7, 0($10)  
* 测试lw指令
  >.text  
  ori $1, $1, 1  
ori $2, $2, 2  
ori $3, $3, 3  
ori $4, $4, 4  
ori $5, $5, 5  
ori $6, $6, 6  
ori $7, $7, 7  
ori $8, $8, 8  
ori $9, $9, 9  
ori $10, $10, -4
ori $11, $11, 12
sw $1, 4($11)  
sw $2, 0($11)  
sw $3, -4($11)  
sw $4, 4($0)  
sw $5, 0($0)  
sw $6, 4($10)  
sw $7, 0($10)  
lw $8, 4($11)  
lw $9, 0($11)  
lw $10, -4($11)  
lw $11, 4($0)  
lw $12, 0($0)  
lw $13, 4($10)  
lw $14, 0($10) 
* 测试lui指令
  >.text  
ori $1, $1, 5  
ori $2, $2, 23  
lui $3, 0x1023  
lui $4, 0x5678  
ori $5, $5, 50  
ori $6, $6, 60  
addu $7, $3, $4  
addu $8  $5, $6  
* 测试转发
  >.text  
ori $22, $0, 64  
ori $1, $0, 116  
ori $4, $0, 140  
ori $28, $0, 228   
ori $29, $0, 228  
addu $18 $28 $22  
addu $29 $1 $18  
addu $4 $29 $18  
addu $5 $4 $18  
lw $20 100($0)  
sw $24 100($0)  
* 测试暂停
  >.text  
lw $t1, 120($0)   
beq $t1,$t2, label4  
nop  
ori $s3, $s3,3  
ori $s4, $s4,4  
label4:  
ori $5, $5, 5  
ori $6, $6, 6  
ori $t1, $t1, 400  
ori $t2, $t2, 600  
ori $t3, $t3, 100  
ori $t4, $t4, 50  
sw $t3, 100($0)  
lw $t4, 100($0)  
subu $t1, $t1,$t4  
addu $t2, $t2, $t4  
* P7测试方案：
1. 检验增加指令后 p6 部分是否仍正确，Req置0后交p6强测是否通过；
2. 检验新增的 eret、mtc0、mfc0 行为是否正确，以及它们的阻塞转发是否正确；
3. 对所有可能的异常进行测试，看行为是否正确；
4. 对所有可能的中断进行测试，看行为是否正确，尤其检验延迟槽指令阻塞或者中断时行为是否正确，即BD位是否正确；
5. 对 IO 操作进行测试，对 timer 进行读写操作；
6. 一些特殊情况，如 eret 前使用乘除模块、使用乘除模块前中断。
## 三、思考题  
 1. 1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？
 * 答 ： 鼠标和键盘产生中断信号，进入中断处理区相应位置，CPU通过load型指令将输入信号从键盘或者鼠标中读入寄存器。
 2. 请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）
*  答 ： 已经制定好的地址方便我们统一对指令的异常或者中断来进行统一处理，实现简便，效率高；若由用户自定义入口地址，也能实现我们希望的功能，可能会出现实现繁琐，影响运行效率等问题。
 3. 为何与外设通信需要 Bridge？
  * 答： 系统桥一端直接接受CPU中M级传来的地址, 写使能, 写数据, 并向CPU发送读出的数据; 另一端向外设与数据存储器发送地址与写使能, 写数据, 并从外设与数据存储器接受读出的数据。
 4. 请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。
  * 答：​ 中断模式0：将计数器写使能变为0，并且保持中断信号持续有效，直到计数器写使能为1。该模式通常用于定时中断。
  * 中断模式1：只保持一周期的中断信号，并重新载入计数器初值，再次倒计时。该模式通常用于产生周期性脉冲。
   状态转移图如下：
  ![模式0.png](C:\Users\86182\Desktop\模式0.png)
  ![模式1.png](C:\Users\86182\Desktop\模式1.png)
 5. 倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？
  * 答：这个空泡nop的PC和BD都是0，宏观PC便显示了错误的值，并且若此时发生了中断，EPC还会存入错误的值；
  *     因此，产生的空泡指令应该保留原指令的PC值和BD值，防止宏观PC出错以及EPC出错。
 6. 为什么 jalr 指令的两个寄存器不能相同，例如 jalr $31, $31？
 * 答：因为可能会带来不必要的阻塞或者异常。